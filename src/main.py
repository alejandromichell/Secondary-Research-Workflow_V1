"""
Main entry point for the secondary research workflow application.
This file sets up a FastAPI server to handle research requests.
"""

from typing import List, Optional

from fastapi import FastAPI, BackgroundTasks
from fastapi.responses import HTMLResponse
from pydantic import BaseModel

from .workflows.research_workflow import SecondaryResearchWorkflow
import asyncio
import json
import os
from typing import Dict, Any

# --- Pydantic Model for Simplified Incoming Research Requests ---
class ResearchRequest(BaseModel):
    topic: str


# --- FastAPI Application ---
app = FastAPI(
    title="Secondary Research Workflow API (Simplified Mode)",
    description="An API to initiate and manage simplified research workflows.",
    version="1.1.0"
)

workflow = SecondaryResearchWorkflow()

# Persistent storage for research results
STORAGE_FILE = "research_results.json"

def load_research_results() -> Dict[str, Any]:
    """Load research results from file."""
    if os.path.exists(STORAGE_FILE):
        try:
            with open(STORAGE_FILE, 'r') as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            return {}
    return {}

def save_research_results(data: Dict[str, Any]):
    """Save research results to file."""
    try:
        with open(STORAGE_FILE, 'w') as f:
            json.dump(data, f, indent=2)
    except IOError as e:
        print(f"Warning: Could not save research results: {e}")

# Load existing research results
research_results_storage = load_research_results()

def generate_html_report(topic: str, research_results: dict, metadata: dict) -> str:
    """Generate a formatted HTML report from research results."""
    
    # Extract sections
    research_plan = research_results.get("research_plan", "")
    data_collection = research_results.get("data_collection_strategy", "")
    analysis = research_results.get("analysis_and_synthesis", "")
    swot = research_results.get("swot_analysis", "")
    final_report = research_results.get("final_report", "")
    
    # Get metadata
    model_used = metadata.get("model", "Unknown")
    api_used = metadata.get("api_used", "Unknown")
    
    html = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Report: {topic}</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .container {{
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }}
        h1 {{
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }}
        h2 {{
            color: #34495e;
            margin-top: 40px;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }}
        h3 {{
            color: #7f8c8d;
            margin-top: 25px;
            margin-bottom: 15px;
        }}
        p {{
            margin-bottom: 15px;
            text-align: justify;
        }}
        .metadata {{
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
            font-size: 0.9em;
        }}
        .section {{
            margin-bottom: 30px;
        }}
        ul, ol {{
            margin-left: 20px;
            margin-bottom: 15px;
        }}
        li {{
            margin-bottom: 8px;
        }}
        .highlight {{
            background-color: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Research Report: {topic}</h1>
        
        <div class="metadata">
            <strong>Generated by:</strong> {api_used} ({model_used})<br>
            <strong>Report Date:</strong> {metadata.get('timestamp', 'Unknown')}<br>
            <strong>Research Steps Completed:</strong> {metadata.get('research_steps_completed', 'Unknown')}
        </div>

        <div class="section">
            <h2>Executive Summary</h2>
            <p>This comprehensive research report provides an in-depth analysis of {topic}, covering research methodology, data collection strategies, market analysis, SWOT assessment, and strategic recommendations. The research was conducted using advanced AI-powered analysis to deliver actionable insights and professional-grade findings.</p>
        </div>

        <div class="section">
            <h2>Research Plan & Methodology</h2>
            <div class="highlight">
                {format_text_as_html(research_plan)}
            </div>
        </div>

        <div class="section">
            <h2>Data Collection Strategy</h2>
            <div class="highlight">
                {format_text_as_html(data_collection)}
            </div>
        </div>

        <div class="section">
            <h2>Analysis & Synthesis</h2>
            <div class="highlight">
                {format_text_as_html(analysis)}
            </div>
        </div>

        <div class="section">
            <h2>SWOT Analysis</h2>
            <div class="highlight">
                {format_text_as_html(swot)}
            </div>
        </div>

        <div class="section">
            <h2>Final Research Report</h2>
            <div class="highlight">
                {format_text_as_html(final_report)}
            </div>
        </div>

        <div class="section">
            <h2>Conclusion</h2>
            <p>This research provides a comprehensive analysis of {topic}, offering valuable insights for decision-makers, researchers, and stakeholders. The findings presented in this report are based on thorough analysis and can serve as a foundation for strategic planning and informed decision-making.</p>
        </div>
    </div>
</body>
</html>
"""
    return html

def format_text_as_html(text: str) -> str:
    """Convert plain text to HTML with proper formatting."""
    if not text:
        return "<p>No content available.</p>"
    
    # Split into paragraphs
    paragraphs = text.split('\n\n')
    html_paragraphs = []
    
    for paragraph in paragraphs:
        paragraph = paragraph.strip()
        if not paragraph:
            continue
            
        # Check if it's a heading (starts with number or is short and ends with colon)
        if (paragraph.startswith(('1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.')) or 
            (len(paragraph) < 100 and paragraph.endswith(':'))):
            # Convert to h3
            clean_text = paragraph.replace(':', '').strip()
            if clean_text.startswith(('1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.')):
                clean_text = clean_text[3:].strip()
            html_paragraphs.append(f"<h3>{clean_text}</h3>")
        else:
            # Regular paragraph
            html_paragraphs.append(f"<p>{paragraph}</p>")
    
    return '\n'.join(html_paragraphs)

@app.on_event("startup")
async def startup_event():
    print("ðŸš€ Secondary Research Workflow API has started in SIMPLIFIED MODE.")
    print("Listening for research requests on http://127.0.0.1:8000")

@app.post("/start-research")
async def start_research_endpoint(request: ResearchRequest, background_tasks: BackgroundTasks):
    """
    This endpoint accepts a simple research topic and starts the workflow.
    """
    print("--- New Simplified Research Request Received ---")
    
    # Adapt the simple request to the format expected by the workflow
    research_data = {
        "topic": request.topic,
        "objectives": [f"Conduct a general research inquiry into {request.topic}"],
        "questions": [f"What are the key aspects of {request.topic}?"],
        "user_context": request.dict()
    }
    
    print(f"Formatted research topic: {research_data['topic']}")
    print("Starting simplified research process in the background...")

    # Create a unique session ID for this research
    session_id = f"research_{request.topic.replace(' ', '_').replace('/', '_')}"
    
    # Store initial status
    research_results_storage[session_id] = {
        "status": "processing",
        "topic": request.topic,
        "message": "Research in progress..."
    }
    save_research_results(research_results_storage)

    # Run the long-running research task in the background
    async def run_research_and_store():
        result = await workflow.execute_research(research_data)
        research_results_storage[session_id] = result
        save_research_results(research_results_storage)
    
    background_tasks.add_task(run_research_and_store)
    
    return {
        "status": "success",
        "message": "Simplified research process initiated in the background.",
        "topic": request.topic,
        "session_id": session_id,
        "check_status_url": f"/research-status/{session_id}",
        "get_report_url": f"/research-report/{session_id}"
    }

@app.get("/research-status/{session_id}")
async def get_research_status(session_id: str):
    """
    Check the status of a research request.
    """
    # Reload from file to get latest data
    current_storage = load_research_results()
    
    if session_id not in current_storage:
        return {
            "status": "error",
            "error": "Research session not found"
        }
    
    result = current_storage[session_id]
    return {
        "session_id": session_id,
        "status": result.get("status", "unknown"),
        "topic": result.get("topic", "Unknown"),
        "message": result.get("message", "No message available")
    }

@app.get("/research-report/{session_id}")
async def get_research_report(session_id: str):
    """
    Get the complete research report for a completed research request.
    """
    # Reload from file to get latest data
    current_storage = load_research_results()
    
    if session_id not in current_storage:
        return {
            "status": "error",
            "error": "Research session not found"
        }
    
    result = current_storage[session_id]
    
    if result.get("status") == "processing":
        return {
            "status": "processing",
            "message": "Research is still in progress. Please check back later.",
            "check_status_url": f"/research-status/{session_id}"
        }
    
    if result.get("status") == "error":
        return {
            "status": "error",
            "error": result.get("error", "Unknown error occurred")
        }
    
    if result.get("status") == "complete":
        return {
            "status": "complete",
            "session_id": session_id,
            "topic": result.get("topic", "Unknown"),
            "research_results": result.get("research_results", {}),
            "metadata": result.get("metadata", {}),
            "session_state": result.get("session_state", {})
        }
    
    return {
        "status": "unknown",
        "message": "Research status is unclear"
    }

@app.get("/research-report-html/{session_id}")
async def get_research_report_html(session_id: str):
    """
    Get the research report formatted as HTML for better readability.
    """
    # Reload from file to get latest data
    current_storage = load_research_results()
    
    if session_id not in current_storage:
        return {
            "status": "error",
            "error": "Research session not found"
        }
    
    result = current_storage[session_id]
    
    if result.get("status") == "processing":
        return {
            "status": "processing",
            "message": "Research is still in progress. Please check back later.",
            "check_status_url": f"/research-status/{session_id}"
        }
    
    if result.get("status") == "error":
        return {
            "status": "error",
            "error": result.get("error", "Unknown error occurred")
        }
    
    if result.get("status") == "complete":
        research_results = result.get("research_results", {})
        topic = research_results.get("topic", "Unknown Topic")
        
        # Generate formatted HTML report
        html_content = generate_html_report(topic, research_results, result.get("metadata", {}))
        
        return {
            "status": "complete",
            "session_id": session_id,
            "topic": topic,
            "html_report": html_content,
            "metadata": result.get("metadata", {})
        }
    
    return {
        "status": "unknown",
        "message": "Research status is unclear"
    }

@app.get("/research-report-view/{session_id}", response_class=HTMLResponse)
async def get_research_report_view(session_id: str):
    """
    Get the research report as a viewable HTML page.
    """
    # Reload from file to get latest data
    current_storage = load_research_results()
    
    if session_id not in current_storage:
        return HTMLResponse("""
        <html><body>
            <h1>Error</h1>
            <p>Research session not found.</p>
        </body></html>
        """, status_code=404)
    
    result = current_storage[session_id]
    
    if result.get("status") == "processing":
        return HTMLResponse("""
        <html><body>
            <h1>Research in Progress</h1>
            <p>Your research is still being processed. Please check back later.</p>
        </body></html>
        """)
    
    if result.get("status") == "error":
        return HTMLResponse(f"""
        <html><body>
            <h1>Error</h1>
            <p>Research failed: {result.get('error', 'Unknown error occurred')}</p>
        </body></html>
        """, status_code=500)
    
    if result.get("status") == "complete":
        research_results = result.get("research_results", {})
        topic = research_results.get("topic", "Unknown Topic")
        
        # Generate formatted HTML report
        html_content = generate_html_report(topic, research_results, result.get("metadata", {}))
        return HTMLResponse(html_content)
    
    return HTMLResponse("""
    <html><body>
        <h1>Unknown Status</h1>
        <p>Research status is unclear.</p>
    </body></html>
    """)

@app.get("/")
async def root():
    return {"message": "Secondary Research Workflow API is running in Simplified Mode."}
